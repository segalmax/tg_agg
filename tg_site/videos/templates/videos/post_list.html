{% extends 'videos/base.html' %}

{% block title %}
    {% if channel %}{{ channel.username }} - Telegram Videos{% else %}Telegram Videos{% endif %}
{% endblock %}

{% block extra_css %}
<style>
.video-card {
    cursor: pointer;
}
.video-card .video-thumbnail {
    width: 100%;
    aspect-ratio: 9 / 16;
    object-fit: cover;
}
.video-card .preview-video {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    aspect-ratio: 9 / 16;
    object-fit: cover;
    z-index: 10;
}
#videoModal .modal-dialog {
    max-width: 90vw;
}
#videoModal video {
    width: 100%;
    max-height: 80vh;
    background: #000;
}
.fallback-container {
    min-height: 400px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #1a1a1a;
}
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <!-- Desktop Sidebar (hidden on mobile) -->
        <div class="col-md-3 col-lg-2 d-none d-md-block bg-white p-3 sticky-top" style="top: 56px; height: calc(100vh - 56px); overflow-y: auto;">
            {% include 'videos/filter_form.html' %}
        </div>
        
        <!-- Main Content -->
        <div class="col-12 col-md-9 col-lg-10">
            <div class="container-fluid py-3">
                {% if channel %}
                <div class="alert alert-info">
                    <strong>Channel:</strong> {{ channel.username }}
                </div>
                {% endif %}
                
                <!-- Results Counter -->
                <div class="results-counter">
                    <strong>Showing {{ total_count|default:page_obj.paginator.count }} posts</strong>
                </div>
                
                <!-- Filter Chips -->
                <div class="filter-chips" id="filterChips">
                    <!-- Dynamically populated by JavaScript -->
                </div>
                
                <!-- Video Grid: 2 cols mobile, 5 cols desktop (with wider cards) -->
                <div class="row row-cols-2 row-cols-lg-4 row-cols-xl-5 g-4">
                    {% for post in page_obj %}
                    <div class="col">
                        <div class="card video-card h-100" 
                             data-channel="{{ post.channel.username }}" 
                             data-post="{{ post.telegram_id }}"
                             data-link="{{ post.link }}"
                             data-text="{{ post.text|escape }}"
                             data-views="{{ post.views|default:'0' }}"
                             data-has-video="{{ post.video_data|yesno:'true,false' }}">
                            <div class="position-relative">
                                {% if post.video_data %}
                                <!-- Static thumbnail -->
                                <video class="card-img-top video-thumbnail" 
                                       preload="none">
                                </video>
                                <!-- Hover preview video (desktop only) -->
                                <video class="preview-video d-none d-md-block" 
                                       muted 
                                       loop 
                                       preload="none">
                                </video>
                                {% else %}
                                <div class="card-img-top video-thumbnail bg-secondary d-flex align-items-center justify-content-center text-white">
                                    <span style="font-size: 48px;">üì∑</span>
                                </div>
                                {% endif %}
                            </div>
                            <div class="card-body p-2">
                                <p class="card-text small mb-1" style="height: 40px; overflow: hidden; line-height: 1.3;">
                                    {{ post.text|truncatewords:10 }}
                                </p>
                                <div class="text-muted" style="font-size: 0.75rem;">
                                    <div>üëÅ {{ post.views|default:"0" }}</div>
                                    <div>{{ post.channel.username }}</div>
                                    <div class="post-datetime" data-datetime="{{ post.date.isoformat }}"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    {% empty %}
                    <div class="col-12">
                        <div class="alert alert-warning">No posts found.</div>
                    </div>
                    {% endfor %}
                </div>
                
                <!-- Pagination -->
                {% if page_obj.paginator.num_pages > 1 %}
                <nav aria-label="Page navigation" class="mt-4">
                    <ul class="pagination justify-content-center">
                        {% if page_obj.has_previous %}
                        <li class="page-item">
                            <a class="page-link" href="?page=1{{ query_string }}">First</a>
                        </li>
                        <li class="page-item">
                            <a class="page-link" href="?page={{ page_obj.previous_page_number }}{{ query_string }}">Previous</a>
                        </li>
                        {% endif %}
                        
                        <li class="page-item disabled">
                            <span class="page-link">Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}</span>
                        </li>
                        
                        {% if page_obj.has_next %}
                        <li class="page-item">
                            <a class="page-link" href="?page={{ page_obj.next_page_number }}{{ query_string }}">Next</a>
                        </li>
                        <li class="page-item">
                            <a class="page-link" href="?page={{ page_obj.paginator.num_pages }}{{ query_string }}">Last</a>
                        </li>
                        {% endif %}
                    </ul>
                </nav>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<!-- Mobile Filter Button -->
<button class="btn btn-primary btn-filter d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#filterOffcanvas">
    üîç Filters
</button>

<!-- Mobile Offcanvas Filters -->
<div class="offcanvas offcanvas-end" tabindex="-1" id="filterOffcanvas">
    <div class="offcanvas-header">
        <h5 class="offcanvas-title">Filters</h5>
        <button type="button" class="btn-close" data-bs-dismiss="offcanvas"></button>
    </div>
    <div class="offcanvas-body">
        {% include 'videos/filter_form.html' %}
    </div>
</div>

<!-- Video Modal -->
<div class="modal fade" id="videoModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered modal-xl">
        <div class="modal-content bg-dark text-white">
            <div class="modal-header border-secondary">
                <h5 class="modal-title" id="videoModalTitle">Video</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <!-- Navigation buttons -->
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <button id="prevPostBtn" class="btn btn-outline-light">
                        <i class="bi bi-chevron-left"></i> Previous
                    </button>
                    <button id="nextPostBtn" class="btn btn-outline-light">
                        Next <i class="bi bi-chevron-right"></i>
                    </button>
                </div>
                
                <!-- Video container (full width on top) -->
                <div id="modalVideoContainer" class="mb-3"></div>
                
                <!-- Post data below video -->
                <div id="modalPostData" class="p-3 bg-black rounded">
                    <!-- Populated dynamically -->
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// ====== Filter Chips ======
function renderFilterChips() {
    const chipsContainer = document.getElementById('filterChips');
    if (!chipsContainer) return;
    
    const chips = [];
    const urlParams = new URLSearchParams(window.location.search);
    
    // Search query
    const searchQuery = urlParams.get('q');
    if (searchQuery) {
        chips.push({
            label: `Search: "${searchQuery}"`,
            param: 'q'
        });
    }
    
    // Channels
    const channels = urlParams.get('channels');
    if (channels) {
        const channelList = channels.split(',').filter(c => c.trim());
        channelList.forEach(channel => {
            chips.push({
                label: `üì∫ ${channel}`,
                param: 'channels',
                value: channel
            });
        });
    }
    
    // Media type (only show if not default 'video')
    const media = urlParams.get('media') || 'video';
    if (media !== 'video') {
        const mediaLabels = {
            'all': 'All posts',
            'photo': 'Photos only',
            'has_media': 'Has media'
        };
        chips.push({
            label: `üé¨ ${mediaLabels[media] || media}`,
            param: 'media'
        });
    }
    
    // Date range
    const dateFrom = urlParams.get('date_from');
    const dateTo = urlParams.get('date_to');
    if (dateFrom || dateTo) {
        const label = dateFrom && dateTo 
            ? `üìÖ ${dateFrom} to ${dateTo}`
            : dateFrom 
                ? `üìÖ From ${dateFrom}`
                : `üìÖ Until ${dateTo}`;
        chips.push({
            label: label,
            param: 'date_range'
        });
    }
    
    // Sort (only show if not default '-date')
    const sort = urlParams.get('sort') || '-date';
    if (sort !== '-date') {
        const sortLabels = {
            'date': 'Oldest First',
            '-views': 'Most Views',
            '-forwards': 'Most Forwards',
            '-replies': 'Most Replies'
        };
        chips.push({
            label: `‚¨ÜÔ∏è ${sortLabels[sort] || sort}`,
            param: 'sort'
        });
    }
    
    // Render chips
    if (chips.length === 0) {
        chipsContainer.innerHTML = '';
        return;
    }
    
    chipsContainer.innerHTML = chips.map(chip => `
        <div class="filter-chip">
            ${chip.label}
            <span class="remove" onclick="removeFilterChip('${chip.param}', '${chip.value || ''}')">√ó</span>
        </div>
    `).join('');
}

function removeFilterChip(param, value) {
    const urlParams = new URLSearchParams(window.location.search);
    
    if (param === 'channels' && value) {
        // Remove specific channel from list
        const channels = (urlParams.get('channels') || '').split(',').filter(c => c.trim());
        const newChannels = channels.filter(c => c !== value);
        if (newChannels.length > 0) {
            urlParams.set('channels', newChannels.join(','));
        } else {
            urlParams.delete('channels');
        }
    } else if (param === 'date_range') {
        urlParams.delete('date_from');
        urlParams.delete('date_to');
    } else {
        urlParams.delete(param);
    }
    
    // If removing media, set it back to default 'video'
    if (param === 'media') {
        urlParams.set('media', 'video');
    }
    
    // Redirect
    const newUrl = urlParams.toString() ? `?${urlParams.toString()}` : '/';
    window.location.href = newUrl;
}

// Render chips on page load
renderFilterChips();

// ====== Video Functionality ======
// Store video URLs to avoid re-fetching
const videoCache = {};
let currentModalCard = null;
let allCards = [];
let currentModalIndex = -1;
let gridVideos = new Map(); // Track grid videos for autoplay

// Format datetime
function formatDateTime(isoString) {
    const date = new Date(isoString);
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    return `${day}/${month}/${year}`;
}

function formatDateTimeFull(isoString) {
    const date = new Date(isoString);
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${day}/${month}/${year} ${hours}:${minutes}`;
}

document.querySelectorAll('.post-datetime').forEach(el => {
    el.textContent = formatDateTime(el.dataset.datetime);
});

// Fetch video URL and cache it
async function getVideoUrl(channel, postId) {
    const cacheKey = `${channel}/${postId}`;
    if (videoCache[cacheKey]) {
        return videoCache[cacheKey];
    }
    
    try {
        const response = await fetch(`/api/video/${channel}/${postId}/`);
        const data = await response.json();
        videoCache[cacheKey] = data;
        return data;
    } catch (err) {
        console.error(`Failed to load video ${cacheKey}:`, err);
        return { video: null, thumbnail: null };
    }
}

// Initialize all video cards
allCards = Array.from(document.querySelectorAll('.video-card'));

allCards.forEach((card, index) => {
    const channel = card.dataset.channel;
    const postId = card.dataset.post;
    const hasVideo = card.dataset.hasVideo === 'true';
    
    if (!hasVideo) return;
    
    const thumbnail = card.querySelector('.video-thumbnail');
    const previewVideo = card.querySelector('.preview-video');
    let videoData = null;
    
    // Load thumbnail immediately
    getVideoUrl(channel, postId).then(data => {
        videoData = data;
        if (data.thumbnail && thumbnail) {
            thumbnail.poster = data.thumbnail;
        }
    });
    
    // Store preview video element for grid autoplay
    if (previewVideo) {
        gridVideos.set(card, previewVideo);
    }
    
    // Click handler for modal (desktop) or fullscreen (mobile)
    card.addEventListener('click', async (e) => {
        e.stopPropagation();
        
        if (!videoData) {
            videoData = await getVideoUrl(channel, postId);
        }
        
        const isMobile = window.innerWidth < 768;
        
        if (isMobile) {
            // Mobile: try to play fullscreen directly
            if (videoData.video) {
                const tempVideo = document.createElement('video');
                tempVideo.src = videoData.video;
                tempVideo.controls = true;
                tempVideo.style.position = 'fixed';
                tempVideo.style.top = '0';
                tempVideo.style.left = '0';
                tempVideo.style.width = '100vw';
                tempVideo.style.height = '100vh';
                tempVideo.style.zIndex = '9999';
                tempVideo.style.backgroundColor = '#000';
                
                document.body.appendChild(tempVideo);
                
                tempVideo.requestFullscreen().then(() => {
                    tempVideo.play();
                }).catch(() => {
                    // Fallback if fullscreen fails
                    tempVideo.play();
                });
                
                tempVideo.addEventListener('ended', () => {
                    document.exitFullscreen().catch(() => {});
                    tempVideo.remove();
                });
                
                tempVideo.addEventListener('pause', () => {
                    setTimeout(() => {
                        document.exitFullscreen().catch(() => {});
                        tempVideo.remove();
                    }, 100);
                });
            } else {
                // No video available - open Telegram
                window.open(card.dataset.link, '_blank');
            }
        } else {
            // Desktop: show modal
            currentModalIndex = index;
            showVideoModal(card, videoData);
        }
    });
});

// IntersectionObserver for grid video autoplay (muted, in viewport)
const observerOptions = {
    root: null,
    rootMargin: '0px',
    threshold: 0.5 // 50% visible
};

const videoObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        const card = entry.target;
        const previewVideo = gridVideos.get(card);
        
        if (!previewVideo) return;
        
        if (entry.isIntersecting) {
            // Load and play video when visible
            const channel = card.dataset.channel;
            const postId = card.dataset.post;
            
            getVideoUrl(channel, postId).then(data => {
                if (data.video && entry.isIntersecting) {
                    previewVideo.src = data.video;
                    previewVideo.muted = true;
                    previewVideo.loop = true;
                    previewVideo.play().catch(err => {
                        console.log('Autoplay failed:', err);
                    });
                }
            });
        } else {
            // Pause and unload when out of viewport
            previewVideo.pause();
            previewVideo.src = '';
        }
    });
}, observerOptions);

// Observe all cards with videos
allCards.forEach(card => {
    if (card.dataset.hasVideo === 'true') {
        videoObserver.observe(card);
    }
});

// Show video in Bootstrap modal (desktop)
async function showVideoModal(card, videoData) {
    currentModalCard = card;
    const modalEl = document.getElementById('videoModal');
    const modal = new bootstrap.Modal(modalEl);
    const container = document.getElementById('modalVideoContainer');
    const title = document.getElementById('videoModalTitle');
    const postData = document.getElementById('modalPostData');
    const prevBtn = document.getElementById('prevPostBtn');
    const nextBtn = document.getElementById('nextPostBtn');
    
    title.textContent = card.dataset.channel;
    
    // Update navigation buttons
    prevBtn.disabled = currentModalIndex === 0;
    nextBtn.disabled = currentModalIndex === allCards.length - 1;
    
    // Display post data
    const postText = card.dataset.text || 'No description';
    const postLink = card.dataset.link;
    const views = card.dataset.views || '0';
    const datetime = card.querySelector('.post-datetime')?.dataset.datetime;
    
    postData.innerHTML = `
        <div class="mb-2"><strong>Channel:</strong> ${card.dataset.channel}</div>
        <div class="mb-2"><strong>Views:</strong> üëÅ ${views}</div>
        <div class="mb-2"><strong>Date:</strong> ${datetime ? formatDateTimeFull(datetime) : 'Unknown'}</div>
        <div class="mb-3"><strong>Description:</strong><br>${postText}</div>
        <a href="${postLink}" target="_blank" class="btn btn-primary">
            <i class="bi bi-telegram"></i> Open in Telegram
        </a>
    `;
    
    container.innerHTML = '';
    
    if (videoData.video) {
        // Video available - autoplay unmuted
        const video = document.createElement('video');
        video.src = videoData.video;
        video.controls = true;
        video.autoplay = true;
        video.style.width = '100%';
        video.style.maxHeight = '70vh';
        video.style.backgroundColor = '#000';
        
        if (videoData.thumbnail) {
            video.poster = videoData.thumbnail;
        }
        
        container.appendChild(video);
        
        // Clean up when modal closes
        modalEl.addEventListener('hidden.bs.modal', () => {
            video.pause();
            video.src = '';
        }, { once: true });
    } else {
        // Video extraction failed - use Telegram embed iframe
        const embedUrl = `https://t.me/${card.dataset.channel}/${card.dataset.post}?embed=1&mode=tme`;
        container.innerHTML = `
            <iframe 
                src="${embedUrl}" 
                width="100%" 
                height="500px" 
                frameborder="0" 
                scrolling="no"
                style="background: #000; border-radius: 8px;">
            </iframe>
        `;
    }
    
    modal.show();
}

// Navigate to next/previous post
async function navigatePost(direction) {
    const newIndex = currentModalIndex + direction;
    if (newIndex < 0 || newIndex >= allCards.length) return;
    
    currentModalIndex = newIndex;
    const newCard = allCards[currentModalIndex];
    const channel = newCard.dataset.channel;
    const postId = newCard.dataset.post;
    
    const videoData = await getVideoUrl(channel, postId);
    showVideoModal(newCard, videoData);
}

// Navigation button handlers
document.getElementById('prevPostBtn').addEventListener('click', () => navigatePost(-1));
document.getElementById('nextPostBtn').addEventListener('click', () => navigatePost(1));

// Keyboard navigation (arrow keys)
document.addEventListener('keydown', (e) => {
    const modalEl = document.getElementById('videoModal');
    const isModalOpen = modalEl.classList.contains('show');
    
    if (!isModalOpen) return;
    
    if (e.key === 'ArrowLeft') {
        e.preventDefault();
        navigatePost(-1);
    } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        navigatePost(1);
    }
});
</script>
{% endblock %}
